<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <title>Document</title>
  </head>
  <body></body>

  <script>
    let search = [
      { title: "BootStrap响应式布局", catagory: "css" },
      { title: "FLEX弹性盒模型", catagory: "css" },
      { title: "MYSQL查询操作", catagory: "mysql" }
    ];
    // -- for 循环 --
    console.log('----- for -----')
    for (let i = 0; i < search.length; i++) {
      search[i].title = `前端开发技能${search[i].title}`;
    }
    console.table(search);

    // -- for of --
    // Value 即 引用类型对象, 此情况才可以发生改变
    console.log('----- for-of ----- ')
    for (const sub of search) {
      sub.title = `2020${sub.title}`;
    }
    console.table(search);

    // -- 值得注意的是 --
    // 如果 arr 为值类型对象, 则不会发生改变, 而是新开内存给 value 赋新值
    // 譬如:
    console.log(' --- 值类型对象不改变, 引用类型对象才会变化 --- ')
    let arr = [1, 2, 3];
    for (let a of arr) {
      a += 10;
    }
    console.table(arr);  // (3) [1, 2, 3]

    // 其中如果换成如下
    let obj = [{ n: 1 }, { n: 2 }, { n: 3 }];
    for (let a of obj) {
      a.n += 10;
    }
    console.table(obj);  
    /* result
    (3) [{…}, {…}, {…}]
    0: {n: 11}
    1: {n: 12}
    2: {n: 13} */
    // -----------------

    // -- for in --
    console.log(' ----- for-in ----- ')
    for (const key in search){
        // if (object.hasOwnProperty(key)){
        //     const element = object[key];
        // }
        search[key].title = `更新${search[key].title}`;

    }
    console.table(search);

  </script>
</html>
