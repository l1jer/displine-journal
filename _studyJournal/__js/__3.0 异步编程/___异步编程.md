# 理解异步编程

- [理解异步编程](#理解异步编程)
  - [JS 单线程](#js-单线程)
  - [异步场景](#异步场景)
    - [定时器 EventLooP](#定时器-eventloop)
    - [Event Loop](#event-loop)
      - [浏览器](#浏览器)
      - [Node.js](#nodejs)
    - [网络请求](#网络请求)
    - [事件绑定](#事件绑定)
    - [Promise](#promise)
- [异步编程方法](#异步编程方法)
  - [回调函数](#回调函数)
  - [事件发布/订阅](#事件发布订阅)
    - [理解](#理解)
    - [实现](#实现)
    - [Node.js 的发布与订阅](#nodejs-的发布与订阅)
  - [Promise](#promise-1)
    - [规范](#规范)
    - [API](#api)
  - [Generator](#generator)
  - [async](#async)

同步: 调用之后得到结果, 再进行下一个任务

异步: 调用之后先进行下一个任务, 再返回之前的结果

> Linux 常用命令
> ps //process status 查看进程状态
> top //table of processes 查看动态进程变化

## JS 单线程

JS 是单线程, 通过**浏览器内核多线程**来实现异步

> 这是因为 Javascript 这门脚本语言诞生的使命所致：JavaScript 为处理页面中用户的交互，以及操作 DOM 树、CSS 样式树来给用户呈现一份动态而丰富的交互体验和服务器逻辑的交互处理。如果 JavaScript 是多线程的方式来操作这些 UI DOM，则可能出现 UI 操作的冲突； 如果 Javascript 是多线程的话，在多线程的交互下，处于 UI 中的 DOM 节点就可能成为一个临界资源，假设存在两个线程同时操作一个 DOM，一个负责修改一个负责删除，那么这个时候就需要浏览器来裁决如何生效哪个线程的执行结果。当然我们可以通过锁来解决上面的问题。但为了避免因为引入了锁而带来更大的复杂性，Javascript 在最初就选择了单线程执行。

> 其中 Chromium 作为浏览器拥有五个进程: 浏览器进程, 渲染进程, GPU 进程, 网络进程和插件进程.

**渲染进程**包括:

- **GUI 线程** //渲染页面布局

  - 负责渲染浏览器界面 HTML 元素,当界面需要重绘(Repaint)或由于某种操作引发回流(reflow)时,该线程就会执行。在 Javascript 引擎运行脚本期间,GUI 渲染线程都是处于挂起状态的,也就是说被”冻结”了.

  - 和 JS 引擎线程互斥: 由于 JavaScript 是可操纵 DOM 的，如果在修改这些元素属性同时渲染界面（即 JavaScript 线程和 UI 线程同时运行），那么渲染线程前后获得的元素数据就可能不一致了。因此为了防止渲染出现不可预期的结果，浏览器设置 GUI 渲染线程与 JavaScript 引擎为互斥的关系，当 JavaScript 引擎执行时 GUI 线程会被挂起，GUI 更新会被保存在一个队列中等到引擎线程空闲时立即被执行。

- **JS 引擎线程** //解析&执行 JS, 与 GUI 互斥线程(因为都要操作 DOM)

  - 也可以称为 JS 内核，主要负责处理 Javascript 脚本程序，例如 V8 引擎。Javascript 引擎线程理所当然是负责解析 Javascript 脚本，运行代码。
  - JS 阻塞页面加载:由于 GUI 渲染线程与 JavaScript 执行线程是互斥的关系，当浏览器在执行 JavaScript 程序的时候，GUI 渲染线程会被保存在一个队列中，直到 JS 程序执行完成，才会接着执行。因此如果 JS 执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞的感觉。

- **定时触发器线程** //setTimeout & setInterval
  - 浏览器定时计数器并不是由 JavaScript 引擎计数的, 因为 JavaScript 引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确, 因此通过单独线程来计时并触发定时是更为合理的方案。
- **事件触发线程** //将满足触发条件的事件放入任务队列
  - 当一个事件被触发时该线程会把事件添加到待处理队列的队尾，等待 JS 引擎的处理。这些事件可以是当前执行的代码块如定时任务、也可来自浏览器内核的其他线程如鼠标点击、AJAX 异步请求等，但由于 JS 的单线程关系所有这些事件都得排队等待 JS 引擎处理。
- **异步 HTTP 请求线程** //XHR 所在线程, 比如 AJAX 请求
  - 在 XMLHttpRequest 在连接后是通过浏览器新开一个线程请求， 将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件放到 JavaScript 引擎的处理队列中等待处理。

## 异步场景

### 定时器 EventLooP

应用场景: 防抖, 节流, 动画, 倒计时

1. 调用 webAPIs(浏览器提供的一种能力), 比如 setTimeout
2. 定时器线程计数 2s
3. 事件触发线程将定时器事件放入任务队列
4. 主线程通过 EventLoop 遍历任务队列

### Event Loop

#### 浏览器

异步实现:

1. 宏观: 浏览器多线程
2. 微观: Event Loop //事件循环

**MacroTask** - [script, setTimeout/setInterval, setImmediate, I/O, UI rendering]

**MicroTask** - [Promise, Object.observe(监听对象变化), MutationObserver(监听 DOM 结构变化), postMessage]

#### Node.js

架构:

- node-core //Nodejs API 核心 JS 库
- 绑定 //包装和暴露底层语言
- v8(Chrome 开源 js 引擎) / libuv
  > Libuv (第三方库, Node.js 异步编程的基础, Node 底层的 io 引擎, c 语言编写事件驱动库, 异步方式返回结果给 v8 引擎)

阶段 Phase:

1. times //执行 timer 回调\*\*
2. pending callbacks //系统操作回调
3. idle, prepare //内部使用
4. poll //等待新 I/O 事件\*\*
5. check //执行 setImmediate 回调\*\*
6. close callbacks //内部使用, 执行 socket onClose

**每个阶段都有一个 Callbacks 的 FIFO 队列需要执行**. 当 EL(EventLoop) 运行到一个被指定阶段时, 该阶段的 FIFO 队列会被执行, 当队列的 Callbacks 执行完或者执行的 Callbacks 数量超过该阶段的上限时, EL 才会转入下一个阶段.

**Poll Phase**

1. 计算应该被 block 多久
2. 处理 poll 队列事件
3. 处理完在没有 callbacks 的情况下, 没有 timers 才会进入 check 阶段
   > 进入 poll 阶段，如果队列不为空或者不受限，执行队列的 callback
   >
   > > 否则，检查是否设置了 setImmediate callback, 如果是，进入 check 阶段
   >
   > > 如果否，等待 callback 加入 poll 队列，这时检查定时器是否到时间。
   >
   > > > 如果否，等待 callback 加入 poll 队列
   >
   > > > 如果是，进入 timers 阶段

**process.nextTick()**

异步 node API, 单不属于 EL 阶段, 调用此方法会暂停 EL 先进行此方法回调.

### 网络请求

### 事件绑定

### Promise

# 异步编程方法

## 回调函数

## 事件发布/订阅

### 理解

publisher --发布消息--> Event Centre <--订阅消息--> subcriber

### 实现

对象来存储发布内容

发布订阅事件 -> 数组

传统 callback 写成 subscribe

| 优点 | 松耦合(可多层嵌套), 高灵活(可多次触发事件) |
| ---- | ------------------------------------------ |
| 缺点 | 无法确保消息被触发,或者触发几次            |

在 promise 出现之前, 这是非常普遍的使用方式

### Node.js 的发布与订阅

方法默认异步 `readFile`, 同步方法为 `readFileSync`

- EventEmitter
  - 事件触发与事件监听器的封装
  - const { EventEmitter } = require('events');
  - 产生事件的对象为 events.EventEmitter 的实例
  - 继承方式使用
  - emit, on, once, addEventListener, removeEventListener

## Promise

### 规范

- A+ 术语

  - promise //一个拥有 then 方法的对象或函数,
  - thenable //一个定义了 then 方法的对象或函数
  - value //任何 js 的合法值
  - error, exception //throw 语句抛出的值
  - reject, reason //一个标示 promise 被拒绝原因的值

- then 方法
  - const promise2=promise1.then(onFulfilled, onRejected);
  - then 方法的参数
    - 两个函数参数
    - onFulfilled 在 promise 完成后被调用, onRejected 在 promise 被拒绝执行后调用
    - 只能被调用一次
  - then 方法可以调用多次, 返回值必须是 promise

### API

## Generator

## async
