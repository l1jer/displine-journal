## 进程与线程

### 进程 Process

- [进程与线程](#进程与线程)
  - [进程 Process](#进程-process)
    - [概念 Concept](#概念-concept)
    - [进程组成 Component](#进程组成-component)
    - [进程特征 Specification](#进程特征-specification)
    - [进程控制](#进程控制)
      - ["原语"](#原语)
      - [~~相关`原语`的背后需要完成什么事情呢?~~](#s相关原语的背后需要完成什么事情呢s)
        - [~~a. 进程的创建~~](#sa-进程的创建s)
        - [~~b. 进程的终止~~](#sb-进程的终止s)
        - [~~c. 进程的阻塞和唤醒 //两者要成对出现~~](#sc-进程的阻塞和唤醒-两者要成对出现s)
    - [进程通信](#进程通信)
  - [线程 Thread](#线程-thread)
    - [线程的实现方式](#线程的实现方式)
      - [用户级线程 User-level Thread (ULT)](#用户级线程-user-level-thread-ult)
      - [内核级线程 Kernal-Level Thread (KLT)](#内核级线程-kernal-level-thread-klt)
    - [多线程模型](#多线程模型)
      - [一对一模型](#一对一模型)
      - [多对一模型](#多对一模型)
      - [多对多模型](#多对多模型)
  - [处理机调度](#处理机调度)
    - [基本概念](#基本概念)
    - [三层调度](#三层调度)
      - [高级调度/作业调度](#高级调度作业调度)
      - [中/内存调度](#中内存调度)
      - [低/进程调度](#低进程调度)
    - [三层调度的联系/对比](#三层调度的联系对比)
    - [补充](#补充)
      - [进程和线程的区别和关系](#进程和线程的区别和关系)
      - [多进程和多线程](#多进程和多线程)
      - [进程的”挂起态”](#进程的挂起态)
      - [七状态模型(内存调度)](#七状态模型内存调度)
    - [进程调度](#进程调度)
      - [进程调度的时机](#进程调度的时机)
      - [进程调度的切换](#进程调度的切换)
      - [进程调度的过程](#进程调度的过程)
      - [进程调度的方式](#进程调度的方式)
    - [调度算法](#调度算法)
      - [先入先服务](#先入先服务)
      - [短作业优先](#短作业优先)
      - [高响应比优先](#高响应比优先)
    - [调度算法的评价指标](#调度算法的评价指标)

> "互斥锁"（Mutual exclusion，缩写 Mutex），防止多个线程同时读写某一块内存区域。
> 有些房间，可以同时容纳 n 个人，比如厨房。也就是说，如果人数大于 n，多出来的人只能在外面等着。这好比某些内存区域，只能供给固定数目的线程使用。
> 这时的解决方法，就是在门口挂 n 把钥匙。进去的人就取一把钥匙，出来时再把钥匙挂回原处。后到的人发现钥匙架空了，就知道必须在门口排队等着了。这种做法叫做"信号量"（Semaphore），用来保证多个线程不会互相冲突。
> 操作系统的设计，因此可以归结为三点：
> （1）以多进程形式，允许多个任务同时运行；
> （2）以多线程形式，允许单个任务分成不同的部分运行；
> (3）提供协调机制，一方面防止进程之间和线程之间产生冲突，另一方面允许进程之间和线程之间共享资源。

不难看出，mutex 是 semaphore 的一种特殊情况（n=1 时）。也就是说，完全可以用后者替代前者。但是，因为 mutex 较为简单，且效率高，所以在必须保证资源独占的情况下，还是采用这种设计。

#### 概念 Concept

是动态的, 是程序的一次执行过程, 每一个被创建的进程都会被操作系统赋予一个 唯一的`Process ID (PID)`, 其中还会被操作系统记录该进程的`用户 ID (UID)`, `资源分配`和`运行情况`, 即`进程控制块 (PCB)`.

一个`进程实体(进程映像)`是由 PCB,程序段和数据段组成, 进程是动态的, 而进程实体是静态的.

**进程是进程实体的运行过程, 是系统进行`资源分配`和`调度(操作系统决定让某个进程在 CPU 上运行)`的一个独立单位.**

---

#### 进程组成 Component

**进程控制块 (PCB: Process Control Block)**: `进程描述信息`, `进程控制和管理信息`, `资源分配清单`和`处理机相关信息`, 当进程结束时会被操作系统回收.

**程序段**: 程序的代码(指令序列)

**数据段**: 运行过程中所产生的数据们

---

#### 进程特征 Specification

- **动态性(基本特征)**: 是程序的一次执行过程, 是动态地产生, 变化和消亡的

- **并发性**: 内存中有多个进程实体, 各进程可并发执行

- **独立性**: 独立运行, 获得资源和接受调度

- **异步性**: 各个进程按照其各自独立的, 不可预知的速度向前推进, 操作系统要提供`"进程同步机制”`来解决异步问题.

  会导致并发程序执行结果的不确定性

- **结构性**: 每个进程都会配置一个 PCB. 结构上看, 进程由程序段,数据段和 PCB 组成

---

#### 进程控制

##### "原语"

(特殊程序, 具有原子性, 过程不可被中断, '一气呵成’)来实现进程控制.

原语的原子性是通过`”关中断指令”`和`”开中断指令”`这两个特权指令来实现: 如果在开中断指令和开中断指令之间接收到外部中断信号, 则会到开中断指令执行后再执行外部中断信号, 因此实现原子性.

##### ~~相关`原语`的背后需要完成什么事情呢?~~

~~**\*\*\*\*\*以下内容仅理解即可\*\*\*\*\***~~

###### ~~a. 进程的创建~~

1. ~~**创建原语** // 这里从创建态 -> 就绪态度~~

   1. ~~申请空白 PCB~~
   2. ~~为新进程分配所需资源~~
   3. ~~初始化 PCB~~
   4. ~~将 PCB 插入就绪队列~~

2. ~~**引起进程创建的事件**~~

   - ~~用户登录: 分时系统中, 用户登录成功, 系统会为其建立一个新进程;~~

   - ~~作业调度: 多道批处理系统中, 有新的作业放入内存时, 会为其建立一个新进程;~~

   - ~~提供服务: 用户向操作系统提出某些请求时, 会新建一个进程处理该请求;~~

   - ~~应用请求: 由用户进程主动请求创建一个子进程~~

###### ~~b. 进程的终止~~

1. ~~**撤销原语** // 就绪态/阻塞态/运行态 -> 终止态 -> 无~~
   1. ~~从 PCB 集合中找到终止进程的 PCB~~
   2. ~~若进程正在运行, 立即剥夺 CPU, 将 CPU 分配给其他进程~~
   3. ~~终止其所有`子进程`~~
   4. ~~将该进程拥有的所有资源归还给父进程/操作系统~~
   5. ~~删除 PCB~~
2. ~~**引起进程终止的事件**~~
   - ~~正常结束: 进程自己请求结束, Exit 系统调用~~
   - ~~异常结束: 非法使用特权指令/整数除以 0, 被操作系统强行杀掉~~
   - ~~外界干预: 用户主动杀掉进程, 任务管理器/CtrlAltDelete~~

###### ~~c. 进程的阻塞和唤醒 //两者要成对出现~~

1. ~~**阻塞**~~
   ~~1. **阻塞原语** // 运行态 -> 阻塞态~~
   ~~1. 找到要阻塞的进程对应的 PCB~~
   ~~2. 保护进程运行现场, 设置 PCB 状态为’阻塞态’, 暂时停止进程运行~~
   ~~3. 将 PCB 插入相应事件的等待队列~~
   ~~2. **引起进程阻塞的事件**~~
   ~~1. 需要等待系统分配某种资源~~
   ~~2. 需要等待相互合作的其他进程完成工作~~ 2. ~~**唤醒**~~ 1. ~~**唤醒原语** // 阻塞态 -> 就绪态~~ 1. ~~在事件等待队列中找到 PCB~~ 2. ~~将 PCB 从等待队列移除. 设置进程为'就绪态’~~ 3. ~~将 PCB 插入就绪队列, 等待被调度~~ 2. ~~**引起进程唤醒的事件** -> **等到的事件发生**~~ 1. ~~当前进程时间片段~~ 2. ~~有更高优先级的进程到达~~ 3. ~~当前进程主动阻塞~~ 4. ~~当前进程终止~~

---

#### 进程通信

进程之间的信息交换/传递, 进程是分配系统资源的单位(包括内存地址空间), 各进程的内存地址空间是`相互独立`的, 处于安全性考虑, 一个进程不能直接访问另一个进程的地址空间, 操作系统提供了`共享存储`, `消息传递`和`管道通信`来实现安全和必要的进程通信.

**共享内存**(基于`数据结构(速度慢限制多的低级通信)`和`存储区(更快的高级通信)`的共享): 两个进程通过此进行通信, 但是对其访问时互斥的, 互斥访问是通过操作系统提供的工具来实现

**消息传递(直接和间接[信箱]通信方式)**: 进程间的数据交换以格式化的消息(Message)为单位, 进程通过操作系统提供的”发送消息/接收消息”两个原语进行数据交换.

**管道通信**: 用于连接读写进程的一个共享文件(Pipe), 即在内存中开辟一个大小固定的缓冲区, 只能采用半双工通信即单向通信, 只有设置两个管道才能实现双向同时通信,

---

### 线程 Thread

#### 线程的实现方式

##### 用户级线程 User-level Thread (ULT)

从**用户视角**看到的线程, 其切换在**用户空间**即可完成, **无需切换到核心态**, 线程管理的系统**开销小**, **效率高**; 但是**并发度**低, 当一个用户级线程被阻塞后, 整个进程都会被阻塞.

##### 内核级线程 Kernal-Level Thread (KLT)

从**操作系统内核视角**看到的线程, **操作系统内核**来完成其管理工作, 其切换在**核心态**下才能完成, **并发能力强**, 多线程可以在多和处理机上并行执行; 线程管理的成本高, 开销大, 一个用户进程会占用多个内核级线程由操作系统内核完成.

---

#### 多线程模型

##### 一对一模型

**用户级线程\*1 --only--> 内核级线程\*1**, 每个用户进程包含 n 个 用户级线程数 和 n 个 内核级线程数, **阻塞不影响其他线程**, 需要切换至**核心态**切换线程, so **强并发, 高成本, 大开销**

##### 多对一模型

**用户级线程\*n --> 内核级线程\***1, **进程\*1 --only--> 内核级线程\*1**, **用户态**下可以完成, **小开销**, **高效率**, **阻塞影响整个进程**, **低并发**, 多个线程不可以在多和处理机上并行运行, **操作系统只”看得见"内核级线程, 因此只有<u>内核级线程</u>才是处理机分配的单位.**

##### 多对多模型

**n\*用户级线程 --> m\*内核级线程**, 且 n>=m; **用户进程\*1 --> m\*内核级线程**, **高并发**,**低开销**, 解决了之前两个模型的缺点, 可以理解为 --> 用户级线程是<u>代码逻辑</u>, 而内核级线程(同时是**处理机分配的单位**)是<u>运行机会</u>, 一段代码逻辑只有获得了运行机会才能被 CPU 执行.

---

### 处理机调度

#### 基本概念

按某种算法选择一个进程将处理机分配给它

#### 三层调度

##### 高级调度/作业调度

按照某种规则\*, 从后备队列中选择合适的作业将其调入内存, 并为其创建进程.

##### 中/内存调度

按照某种规则\*, 从挂起队列中选择合适的进程将其数据调回内存.

##### 低/进程调度

按照某种规则\*, 从就绪队列中选择一个进程为其分配处理机.

#### 三层调度的联系/对比

| 高级调度 | 外存 -> 内存 / 面向作业 | 发生频率最低 |
| -------- | ----------------------- | ------------ |
| 中级调度 | 外存 -> 内存 / 面向进程 | ... 中等     |
| 低级调度 | 内存 -> CPU             | ... 最高     |

#### 补充

##### 进程和线程的区别和关系

- 进程是操作系统分配资源的最小单位，线程是程序执行的最小单位。
- 一个进程由一个或多个线程组成，线程是一个进程中代码的不同执行路线；
- 进程之间相互独立，但同一进程下的各个线程之间共享程序的内存空间(包括代码段、数据集、堆等)及一些进程级的资源(如打开文件和信号)。
- 调度和切换：线程上下文切换比进程上下文切换要快得多。

##### 多进程和多线程

- 多进程：**多进程指的是在同一个时间里，同一个计算机系统中如果允许两个或两个以上的进程处于运行状态**。多进程带来的好处是明显的，比如你可以听歌的同时，打开编辑器敲代码，编辑器和听歌软件的进程之间丝毫不会相互干扰。
- 多线程是指程序中包含多个执行流，即在一个程序中可以同时运行多个不同的线程来执行不同的任务，也就是说**允许单个程序创建多个并行执行的线程来完成各自的任务**。

##### 进程的”挂起态”

为减轻系统负担, 提高资源利用率, 暂时不执行的进程会被调到外存从而变成”挂起态”.

##### 七状态模型(内存调度)

五状态的基础上加入`就绪挂起`和`阻塞挂起`两种状态.

![image-20200322214412628](/Users/jerry/Library/Application Support/typora-user-images/image-20200322214412628.png)

---

#### 进程调度

##### 进程调度的时机

- 主动放弃
  - 进程正常终止
  - 运行过程中发生异常而终止
  - 主动阻塞(e.g. 等待 I/O)
- 被动放弃
  - 分给进程的时间片用完
  - 有更紧急的事情需要处理(e.g. I/O 中断)
  - 有更高优先级的进程进入就绪队列

##### 进程调度的切换

广义的进程调度 即`狭义的进程调度(从就绪队列中选中一个要运行的进程)`+`切换(一个进程让出处理机, 由另一个进程占用处理机的过程)`.

##### 进程调度的过程

1. 对原来运行进程各种数据的保存;

2. 对新的进程各种数据的恢复.

   **\*\*频繁进程切换和调度会使整个系统的效率降低**

##### 进程调度的方式

- 非剥夺调度方式(非抢占式): 只能由当前运行的进程主动放弃 CPU
- 剥夺调度方式(抢占式): 可由操作系统剥夺当前进程的 CPU 使用权.

#### 调度算法

##### 先入先服务

公平原则, 按照进程或作业的先后顺序进行服务, 当用于作业调度时, 优先调度到达后备队列; 进程调度时, 优先调度达到就绪队列,

##### 短作业优先

##### 高响应比优先

#### 调度算法的评价指标

**CPU 利用率 = CPU 忙碌时间 / 总时间**

**系统吞吐量 = 总完成作业数/总共消耗时间**

**作业周转时间 = 作业完成时间 - 作业提交时间**

**带权周转时间 = 作业周转时间 / 作业实际运行时间**

**等待时间: 进程/作业 等待被服务的时间之和**

**响应时间: 从用户提交请求到首次产生相应所用的时间**
