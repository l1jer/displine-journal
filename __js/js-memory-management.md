#### JS 内存管理

| 垃圾回收     | JS  在创建变量时分配内存, 并且在不再使用它们时"自动"释放内存, 导致内存泄漏容易被忽略 |
| ------------ | ------------------------------------------------------------ |
| 内存生命周期 | 分配 -> 使用 -> 释放                                         |



###### **定义变量时, JS 便完成了内存分配**

```js
var n = 123; 				//给数值变量分配内存
var s = "azerty";  	//给字符串分配内存
var o = {						//给对象及其包含的值分配内存
  a: 1,
  b: null};

//给数组及其包含的值分配内存（=对象）
var a = [1, null, "abra"]; 	

//给函数（可调用的对象）分配内存
function f(a)
	{							
  return a + 2;
	}					
```

```js
someElement.addEventListener('click', function(){
someElement.style.backgroundColor = 'blue';}, false);  //函数表达式也能分配一个对象
```



###### **一些函数调用结果是分配对象内存**

```js
var s = "azerty"; 	// s2 是一个新的字符串
var s2 = s.substr(0, 3);	// 因为字符串是不变量，
													// JavaScript 可能决定不分配内存， 
													// 只是存储了 [0-3] 的范围。
var a = ["ouais ouais", "nan nan"];	// 新数组有四个元素，是 a 连接 a2 的结果
var a2 = ["generation", "nan nan"];
var a3 = a.concat(a2); 
```



##### **一些方法是分配新 变量/对象**

```js
var s = "azerty"; 				// s2 是一个新字符串 , 因为字符串是不变量
var s2 = s.substr(0, 3);	// JS可能决定不分配内存, 只是存储了 [0-3] 的范围
var a = ["ouais ouais", "nan nan"]; 	// 新数组有四个元素，是 a 连接 a2 的结果
var a2 = ["generation", "nan nan"];
var a3 = a.concat(a2); 

var a = 10; 			// 分配内存
console.log(a); 	// 对内存的使用

```



**最初级的垃圾回收算法: 引用计数垃圾收集**

```js
var o = { 		// 两个对象被创建，一个作为另一个的属性被引用，另一个被分配给变量o
  a: {				// 很显然，没有一个可以被垃圾收集
    b:2
  }}; 
var o2 = o;		// o2变量是第二个对“这个对象”的引用
o = 1; 				// 现在，“这个对象”的原始引用o被o2替换了
var oa = o2.a; 	// 引用“这个对象”的a属性
								// 现在，“这个对象”有两个引用了，一个是o2，一个是oa
o2 = "yo"; 	// 最初的对象现在已经是零引用了
						// 他可以被垃圾回收了
						// 然而它的属性a的对象还在被oa引用，所以还不能回收
oa = null; 		// a属性的那个对象现在也是零引用了
	 						// 它可以被垃圾回收了

引用计数算法是个简单有效的算法。但它却存在一个致命的问题：循环引用。
如果两个对象相互引用，尽管他们已不再使用，垃圾回收不会进行回收，导致内存泄露.
```

