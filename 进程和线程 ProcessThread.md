### 进程 Process

#### 概念 Concept

是动态的, 是程序的一次执行过程, 每一个被创建的进程都会被操作系统赋予一个 唯一的`Process ID (PID)`, 其中还会被操作系统记录该进程的`用户 ID (UID)`, `资源分配`和`运行情况`, 即`进程控制块 (PCB)`.

一个`进程实体(进程映像)`是由 PCB,程序段和数据段组成, 进程是动态的, 而进程实体是静态的.

__进程是进程实体的运行过程, 是系统进行`资源分配`和`调度(操作系统决定让某个进程在 CPU 上运行)`的一个独立单位.__

---------------------------------

#### 进程组成 Component

__进程控制块 (PCB: Process Control Block)__: `进程描述信息`, `进程控制和管理信息`, `资源分配清单`和`处理机相关信息`, 当进程结束时会被操作系统回收.

__程序段__: 程序的代码(指令序列)

__数据段__: 运行过程中所产生的数据们

-------------

#### 进程特征 Specification

* **动态性(基本特征)**: 是程序的一次执行过程, 是动态地产生, 变化和消亡的

* **并发性**: 内存中有多个进程实体, 各进程可并发执行

* **独立性**: 独立运行, 获得资源和接受调度

* **异步性**: 各个进程按照其各自独立的, 不可预知的速度向前推进, 操作系统要提供`"进程同步机制”`来解决异步问题.

  会导致并发程序执行结果的不确定性

* **结构性**: 每个进程都会配置一个 PCB. 结构上看, 进程由程序段,数据段和 PCB 组成

----------------

#### 进程控制

##### "原语"

(特殊程序, 具有原子性, 过程不可被中断, '一气呵成’)来实现进程控制.

原语的原子性是通过`”关中断指令”`和`”开中断指令”`这两个特权指令来实现: 如果在开中断指令和开中断指令之间接收到外部中断信号, 则会到开中断指令执行后再执行外部中断信号, 因此实现原子性.

##### 相关`原语`的背后需要完成什么事情呢?

**\*\*\*\*\*以下内容仅理解即可\*\*\*\*\***

###### a. 进程的创建

1. **创建原语**		// 这里从创建态 -> 就绪态度
   
   1. 申请空白 PCB
   2. 为新进程分配所需资源
   3. 初始化 PCB
   4. 将 PCB 插入就绪队列
2. **引起进程创建的事件**
   
   * 用户登录: 分时系统中, 用户登录成功, 系统会为其建立一个新进程;
   
   * 作业调度: 多道批处理系统中, 有新的作业放入内存时, 会为其建立一个新进程;
   
   * 提供服务: 用户向操作系统提出某些请求时, 会新建一个进程处理该请求;
   
   * 应用请求: 由用户进程主动请求创建一个子进程

###### b. 进程的终止

1. **撤销原语**		// 就绪态/阻塞态/运行态 -> 终止态 -> 无 
   1. 从 PCB 集合中找到终止进程的 PCB
   2. 若进程正在运行, 立即剥夺 CPU, 将 CPU 分配给其他进程
   3. 终止其所有`子进程`
   4. 将该进程拥有的所有资源归还给父进程/操作系统
   5. 删除 PCB
2. **引起进程终止的事件**
   * 正常结束: 进程自己请求结束, Exit系统调用
   * 异常结束: 非法使用特权指令/整数除以 0, 被操作系统强行杀掉
   * 外界干预: 用户主动杀掉进程, 任务管理器/CtrlAltDelete

###### c. 进程的阻塞和唤醒  //两者要成对出现

 	1. **阻塞**
      	1. **阻塞原语**		// 运行态 -> 阻塞态
           	1. 找到要阻塞的进程对应的 PCB
           	2. 保护进程运行现场, 设置 PCB 状态为’阻塞态’, 暂时停止进程运行
           	3. 将 PCB 插入相应事件的等待队列
      	2. **引起进程阻塞的事件**
           	1. 需要等待系统分配某种资源
           	2. 需要等待相互合作的其他进程完成工作
 	2. **唤醒**
      	1. **唤醒原语**		// 阻塞态 -> 就绪态
           	1. 在事件等待队列中找到 PCB
           	2. 将 PCB 从等待队列移除. 设置进程为'就绪态’
           	3. 将 PCB 插入就绪队列, 等待被调度
      	2. **引起进程唤醒的事件** -> **等到的事件发生**
           	1. 当前进程时间片段
           	2. 有更高优先级的进程到达
           	3. 当前进程主动阻塞
           	4. 当前进程终止

-------

#### 进程通信

进程之间的信息交换/传递, 进程是分配系统资源的单位(包括内存地址空间), 各进程的内存地址空间是`相互独立`的, 处于安全性考虑, 一个进程不能直接访问另一个进程的地址空间, 操作系统提供了`共享存储`, `消息传递`和`管道通信`来实现安全和必要的进程通信.

**共享内存**(基于`数据结构(速度慢限制多的低级通信)`和`存储区(更快的高级通信)`的共享): 两个进程通过此进行通信, 但是对其访问时互斥的, 互斥访问是通过操作系统提供的工具来实现

**消息传递(直接和间接[信箱]通信方式)**: 进程间的数据交换以格式化的消息(Message)为单位, 进程通过操作系统提供的”发送消息/接收消息”两个原语进行数据交换.

**管道通信**: 用于连接读写进程的一个共享文件(Pipe), 即在内存中开辟一个大小固定的缓冲区, 只能采用半双工通信即单向通信, 只有设置两个管道才能实现双向同时通信,

---

### 线程 Thread

#### 